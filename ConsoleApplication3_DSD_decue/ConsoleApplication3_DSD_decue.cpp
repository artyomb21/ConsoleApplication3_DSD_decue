/*
Динамическая структура данных дек или двухсвязный список, не статический массив объектов в котором премушественно быстро
происходит добовление нового элемента (объекта) по сравнению с вектором , то есть для создание нового элемента не требует 
перезаписи старых данных.Связь с элементами обеспечевает левый и правый указатель класса My_dec к массиву элементов а сами 
элементы с помощю указателей r, l к своим же элементам. От отого и название двусвязный, две элементы связаны между собой двумя 
указателями , правый указатель левого и левый указатель правого лемента на левую , прототип нашего объекта будет наш объект класса
Point полями являются x  то есть данные или ключ в реализаций бинарного массива , бинарный массив потом рассмотрим.
указатель r,l указатель на объект по этому тип данных указателья это название класса,они приватные для инкапсуляций в случий 
запрете изменить данные. и по этому для работ с указателями нужны сеттеры и геттеры , а так же реализованый функций ввода и вывода
данных. Тепер рассмотрим класс My_decue  в нем реализований два указателя то есть указатель на элемент массива справого  конца и
указатель на массив с левого конца, с вершин можно сказать. Методоми у нас будут добавить у нас с лево , с право,  создать первый элемент
удалить выбранный нами элемент и показать все элементы, то есть доступ ко всем элементам. add_first()  к указателям имевшим
создается новый элемент с команый new и присваивается указатели к новому объекту, потом add_l()добавить с левой стороны 
проверка если уже есть элемент то создается временный указатель t и привязывается указателями к другим элементам иначе создается 
один в случий когоа у нас первый элемент и вызывается функция add_first(), а потом вызывается его метод input_info() add_r работает 
так же идентично к предедущему методу, ну и инкреминтируется поле количество элементов. Теперь рассмотрим удаление элементов по выбору то есть
функция удаление принимает значение номер элемента и удаляется элемент с номером int. delete(int a) при удалений у нас несколько
случий присуствует первый когда уже пуст массив, второй когда всего один элемент у нас есть, когда элемент первый , последний
и в других случиях у нас удаление происходия создается временный t указатель и спомощю цыкла мы находим нужный элемент get_r()
то есть у нас рассчет элементов произойдет с лево на право, потом предедущий и следущий объекты станут соседними то есть указатели
этих объектов будут указывать на друг друга.Следующий , последний метод работы с элементами у нас показ вывод данных то есть доступ
show_all_object() создается временный указатель t  и с помощю цыкла выводит объекты и те в свой очередь выводит на экран данные
*/
#include <iostream>
using namespace std;
class Point
{
private:
	int x;
	Point* r;
	Point* l;
public:
	Point() : r(NULL), l(NULL), x(0)
	{}
	void input_info()
	{
		cout << " enter x : " << endl;
		cin >> x;
	}
	void show_info()
	{
		cout << x << endl;
	}
	Point* get_r()
	{
		return r;
	}
	Point* get_l()
	{
		return l;
	}
	void set_l(Point* e)
	{
		l = e;
	}void set_r(Point* e)
	{
		r = e;
	}
};
class My_decue
{
private:
	int count;
	Point* R;
	Point* L;
	void add_first() {
		L = new Point;
		R = L;
		L->input_info();
		++count;
	}
public:
	My_decue() :R(NULL), L(NULL), count(0) {}
	void add_l()
	{
		if (count == 0)
		{
			add_first();
		}
		else
		{
			Point* t = new Point;
			t->input_info();
			L->set_l(t);
			t->set_r(L);
			L = t;
			++count;
		}
	}
	void add_r()
	{
		if (count == 0)
		{
			add_first();
		}
		else {
			Point* t = new Point;
			t->input_info();
			R->set_r(t);
			t->set_l(R);
			R = t;
			++count;
		}
	}
	void delate(int a)
	{
		--count;
		if (count == 0)
		{
			count++;
			return;
		}
		else
			if (count == 1)
			{
				delete L;
				L = NULL;
				R = NULL;

			}
			else if (a == 1)
			{
				Point* t = L->get_r();
				delete L;
				L = t;
				L->set_l(NULL);
			}
			else if (a == count)
			{
				Point* t = R->get_r();
				delete R;
				R = t;
				R->set_r(NULL);
			}
			else
			{
				Point* t = L;
				for (size_t i = 0; i < a - 1; i++)
				{
					t = t->get_r();
				}
				t->get_l()->set_r(t->get_r());
				t->get_r()->set_l(t->get_l());
				delete t;
			}
	}
	void show_all_object()
	{
		Point* t = R;
		while (t != NULL)
		{
			t->show_info();
			t = t->get_l();
		}
	}
};
int main()
{
	//testing
	My_decue d;
	d.add_l();
	d.add_l();
	d.add_l();
	//d.add_r();
	d.show_all_object();
	//d.delate(2);
	//cout << endl;
	//d.show_all_object();
}